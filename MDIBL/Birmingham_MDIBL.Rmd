---
title: "BirminghamMDIBL"
author: "Andrew P. Beckerman, University of Sheffield"
date: "28 February 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
____________________________________________________
# Part I starts here....
____________________________________________________

## Using R with Rstudio is AWESOME.  
Building an annotated, archived, repeatable, share-able cross platform record of what you do.

4 panes: 

* the console (engine)
* the script (your code)
* Plots/Packages
* Data Stuff

![Rstudio Four Panes](figures/RStudioFigure2.png)

## Getting Help
There are many ways.  Inside R, we use `?` and `??` or `help.start()`, which spawns a web browser.  Outside R, we use.... google!  But there is something MUCH better.  Stackoverflow.  This has an R channel, and here you will find VERY constructive answers to questions, including code and graphs.  It has rapidly become the go-to location for help.  Lots of R developers are active there.

[LINK to StackR](http://stackoverflow.com/tags/r/info)

![StackR](figures/StackR.png)

## Using R as a calculator

R is a big giant calculator.  Lets practice in the CONSOLE.  As you do these, WATCH what RStudio does with ()'s

## Practical
```{r, eval = FALSE}
# ----------------------------------------------------------------------
# BASIC PRACTICAL
# ----------------------------------------------------------------------
# Maths and Functions
1+1
2*7/8-9
log(exp(1))
log10(1000)
log(1000)
sin(2*pi)
2^10
sqrt(81)
```

#### *What you should know from this.*

* R does maths correctly
* the default logarithm is ln, not base 10
* R has function and objects

Lets look at what more R can do.  Here we see the basics of how R can make sequences.  We see it can make integers using ':' and sequences of certain lengths or 'by' certain steps.

## Moving to the script.
Lets start using the script now.  Add some basic annotation at the top, a place holder for libraries (see below) and a good practice activity - clearing R's brain.

```{r, eval = FALSE}
# NAME
# DATE
# Intro to R script

# libraries I need to use

# clear R's brain
rm(list = ls())
```

Now, lets have some more fun... building sequences of numbers to see how R works.  Add these to your script.  Once you've added them, try this.  Simply place the flashing cursor on the line with `1:10`.  Now, press `CTRL - Enter`.  This should send the code from the script to the console.  Don't forget to save your script too!!! 

```{r, eval = FALSE}
# Sequences, Vectorisation
1:10
seq(from = 1, to = 10, by = 1) # note the three arguments, from, to and by
seq(from = 1, to = 10, length = 12) # note the three arguments, from, to and length
```

#### *What you should know from this.*

* R can make sequences of integers easily
* seq() is a function with at least three arguments.
* from, to, by is a sequence in "steps"
* from, to, length is a sequnce of a fixed number of numbers.
* CTRL - Enter sends info from the script to the console.

## Assignment of numbers, vectors and data to *objects*
You can make objects in R.  We call this ASSIGNMENT, and we typically use `<-` (not `=`, though it is possible)

```{r, eval = FALSE}
# assignments
x <- 1:10

# look at it
x

# use it to make another variable
y <- x^2

# work with both
x+y 
x*y
```

#### *What you should know from this.*

* You can create objects to use.
* The objects can be vectors, matrices, data frames etc.
* R can perform operations with objects.
* operations are by default *element - by - element*
* there is facility for matrix multiplication and linear algebra

## Making some graphics.... BASE graphics

Here we introduce the basics of making a plot.  There are several ways to make pictures.  The most popular now is ggplot2, but there is also the lattice library.  More on packages and libraries below.

Start by making some data.  Then, roll this data in to a data frame, which is like a spreadsheet.

We use the base function `plot()` and a *formula* that specifies the y and the x axes of the plot.

```{r}
# Your first DataFrame
x <- 1:10
y <- x^2

# Make a data.frame from this
myDat <- data.frame(Beer = x, Goggles = y)
myDat
```

#### *What you should know from this.*

* data.frame makes a spreadsheet like object with columns
* we name the data frame using `<-`
* we name the columns inside the data.frame using `=`

Right...lets make the picture!

```{r}
# Your first plot
# FORMULA INTERFACE
plot(y ~ x, data = myDat, type = "b")
```

#### *What you should know from this.*

* plot is nice
* when the data frame has column names that are nice, they look nice on the graph
* the `type` argument *b* is for both.  *p* is for points only. *l* is for lines only.

## *Semi-*ADVANCED Plots
Plots can be customised.... here we alter the limits of the y-axis (`ylim`), the label on the x-axis (`xlab`), the size points (character expansion: `cex`), and make the points filled (point character; `pch`) with cornflowerblue-ness (`col`) .... and note the `c()` is a collector....`ylim = c(0,120)` specifies that the lower and uppler limit of the y-axis is 0 and 120.

```{r}
# FORMULA INTERFACE
plot(y ~ x, data = myDat, type = "b",
     ylim = c(0,120),
     xlab = "Good Beer",
     pch = 19, cex = 2, col = "cornflowerblue")
```

## Back to some Mechanics... Managing Packages
In your 'omics life, you will need to access packages from TWO locations.  CRAN, which is the *C*omprehensive *R* *A*rchive *N*etwork, and Bioconductor.  

[CRAN](http://star-www.st-andrews.ac.uk/cran/) has ~7500 packages available and they are curated at the CRAN Task Views website:

Packages: [LINK](http://star-www.st-andrews.ac.uk/cran/web/packages/) `http://star-www.st-andrews.ac.uk/cran/web/packages/`

TaskViews: [LINK](http://star-www.st-andrews.ac.uk/cran/web/views/)
`http://star-www.st-andrews.ac.uk/cran/web/views/`

[Bioconductor](https://bioconductor.org) is more focused on 'omics, and has a different curation mechanism

Here are the basics for installing stuff.

```{r, eval = FALSE}
# ----------------------------------------------------------------------
# Installing packages
# ----------------------------------------------------------------------

# R-CRAN
# get dplyr and ggplot2 - see http://ggplot2.org and https://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html
# and just use google
# install.packages gets packages and installs them
# SEE RSTUDIO TOO!

install.packages(c('gplots','ggplot2', 'dplyr'))

# R - bioconductor
# the first line grabs a special piece of code to make it easy to get packages from
# BIOCONDUCTOR.
# The second line gets a specific set of packages.... you'll be using these!

source("https://bioconductor.org/biocLite.R")
biocLite(c("edgeR", "DESeq2", "KEGGREST", "pathview","org.Dr.eg.db")
```

Some stuff will happen on your screen when you do this...

Of course, you can also use RStudio to install packages.

![Install](figures/RStudioInstallPKGs.png)


#### Think about packages in this fun way
You should think about packages like this.  You INSTALL PACKAGES from an app store.  To use them, however, we need to invoke a second function (like pressing on the icon).  This is called `library()`

Typically, we'd do the istallations - and you only need to do this ONCE - and then put the library() commands at the top of your script....

```{r, eval = FALSE}
# I need these libraries
library(KEGGREST)
library(pathview)
library(org.Dr.eg.db)
```

## This is what the beginning of your script might look like....  good practice.
![ScriptStart](figures/ScriptStarter.png)

____________________________________________________
# PART II Starts here....
____________________________________________________

## Reading data in from the web, or your own computer.

```{r}
# ----------------------------------------------------------------------
# read some data using read.csv()
# ----------------------------------------------------------------------

# this is a path to data on the web
UrlAddress<-'https://raw.githubusercontent.com/andbeck/RDatas/master/myDF.csv'

# # you will often use a path on your computer
# compAddress<-'C:/Documents/RStuff/myDF.csv' # windows
# compAddress<-'~/Documents/RStuff/myDF.csv' # linux/unix/osx

# get the data
myDF <- read.csv(UrlAddress)
str(myDF)
```

```{r}
# # with comp
# myDF <- read.csv(compAddress)

# # also directly using a path
# myDF <- read.csv('~/Documents/Rstuff')
```

```{r}
# ----------------------------
# make a list (also common)
myList <- list(x = 1:10,
   y = LETTERS[1:5],
   w = matrix(rnorm(100,0,1), nrow = 10, ncol = 10, byrow = TRUE))
```

## What lies below is a bit about how to find your way around data

'omics data structures are highly variable.  Things are stored in data frames and in lists.  Below you have 
- an introduction to `[row, column]`, `$` for grabbing bits of data frames
- an introducto to `subset()` for more efficient grabbing
- an introduction to `[[ ]]` for grabbing things from lists

You'll want to work through these....

-NOTE - lots of people are now using the package dplyr now with verbs select(), slice(), filter() as an alternative to BASE functions.  There are VERY good tutorials online.

```{r}
# ----------------------------------------------------------------------
# Explore the data with important functions in R
# [ ] and $ and ==
# REMEMBER: ROWS THEN COLUMNS
# ----------------------------------------------------------------------
# NOTE - lots of people are using the package dplyr now with
# verbs select(), slice(), filter()
# VERY good tutorials online
# ----------------------------------------------------------------------

# BASE BASICS
myDF[5,2] # 5th row, 2nd column
myDF$expression # expression column
myDF[,1] # column 1
myList[[3]] # 3rd piece of the list => w
```

```{r}
# MORE harder
myList[["w"]][2,] # get the ninth row from the matrix w that is the third element in myList
myList$w[2,] # get the ninth row from the matrix w that is the third element in myList

# More Harder
myDF[51:100,] # rows 51:100 are labeled "B"
myDF[myDF$category=="B",] # rows 51:100, but access functionally by definition in category column.
```


```{r}
# ----------------------------------------------------------------------
# learn how to use subset
# ----------------------------------------------------------------------
subset(myDF, category=="B") # rows
subset(myDF, select = "expression") # columns
subset(myDF, category=="B", select = "expression") # both
```

## summarising data
Here we introduce the use of BASE functions aggregate and tapply, which are used to generate means, standard deviations etc of data by grouping variables (e.g. parts of experimental designs)

-NOTE - lots of people are using the package dplyr now with verbs `select()`, `slice()`, `filter()` along with `summarise()` and `group_by()`;  VERY good tutorials online

```{r}
# ----------------------------------------------------------------------
# Summarize the data using tapply and aggregate
# ----------------------------------------------------------------------
with(myDF, 
	aggregate(x = expression, by = list(category), FUN = mean))

# OR
aggregate(expression ~ category, data = myDF, FUN = mean)

#
with(myDF, 
	tapply(X = expression, INDEX = list(category), FUN = mean))
	
```


```{r}
# YOU CAN assign the values returned by subset, aggregate and tapply to objects
mean.nums <- with(myDF, 
	tapply(X = expression, INDEX = list(category), FUN = mean))

# show me
mean.nums
```

## The apply family and loops
The `apply` family is a very powerfulf family of functions for working with data frames and "applying" functions to rows and columns.  You see above that `tapply()` takes a column of a data frame, divides it up by the levels of a factor from another column, and applies a function to each group.  VERY handy.

The function `apply()` allows us to "apply" a function to each row or column.  This can be very useful.  The first argument is the data frame, the second an indicator (1 or 2) of wheter to work on rows or columns, and the third the function to use.

Lets imagine we want to divide each numeric variable in the small myDat data frame by 10.  This is what we'd do.

```{r}
apply(myDat, 2, function(x) {x/10})
```

Lets dissect this.  We are working with the myDat data frame.  We are going to work on the `COLUMNS`, as we've specified `2`.  The function we are going to use is x/10.  This is interpreted as for every column `x`, do x/10 for every element in x.

Don't get confused by x.  Because we have a `2`, x is EACH column. 

## Transitioning to Unix.
Lets move focus to the console for a moment.... wait.  Have you saved the script?
Use CTRL - 2.  Ohhh - check out the View Menu...
Once in the consol, type:

`ls()`

```{r, echo = FALSE}
# A UNIX LIKE VIEW OF WHAT YOU'VE MADE - did you know that 'ls' is unix command to list files in a directory?
# ls() in R lists objects in the brainspace of R.
# list.files() lists the files in the WORKING directory

# ls() lists the objects in your workspace
ls()
```

Now, lets try a few other commands that are similar in Unix and one extra one.

```{r}
head(myDF) # first six rows
tail(myDF) # last six
str(myDF) # STRUCTURE

getwd() # get the working directory
list.files() # list the files in the working directory

# you can also use the menus via Session -> Set Working Directory to SET the working directory

```

![setwd](figures/Set Working Directory.png)

## Loops.
You will use loops.  Loops count for you and do things many times.  Lets look at a simple loop:

`for(i in 1:10) {print i}`

This reads, count from 1 to 10, calling the counter i.  At each i, print the number that is i.

Lets look at something more challenging

```{r, echo = TRUE, eval = FALSE}
# Set each array value its native level plus noise
for(i in 1:10){
  array[,i] <- ControlExp + rnorm(1000, sd=.5)
}
```

This has the same counter, but is now adding random numbers (`rnorm()`) to something called *ControlExp*, AND for each i, assigning the sum to the *i'th* column in *array* (which we know is by column because [row,column].

## a more in depth overview of various plottings you can do
MANY methods for making plots with `omics data.
- advanced use of `plot()`
- introduction to `ggplot2`
- introduction to `lattice`

```{r}
# ----------------------------------------------------------------------
# make some different types of plots
# plot, barplot, histograms, heatmaps
# reinforce function and arguments
# ----------------------------------------------------------------------

# plot, using the formula method - the best
plot(expression ~ size, data = myDF, pch = 21, bg = "red",
   xlab="Size", ylab = "Expression")
```

```{r}
# alter the color, and use alpha transparency
plot(expression ~ size, data = myDF, pch = 19, cex = 3, col = rgb(0,0,1,alpha = 0.5))

# specifying categories of colours on the points based on a categorical column
# note the special use of [ ]'s
plot(expression ~ size, data = myDF, 
	pch = 19, col = c("green","blue")[category])
```

```{r}
# lattice graphics - super fun exploration
library(lattice) # loads a special graphics library into R's brain

xyplot(expression ~ size | category, data = myDF) # panels
xyplot(expression ~ size, groups = category, data = myDF) # groups

# ggplot graphics - very popular now too
library(ggplot2)
ggplot(myDF, aes(x = size, y = expression))+
	geom_point(col = "red")+
	facet_wrap(~category)

ggplot(myDF, aes(x = size, y = expression, col = category))+
	geom_point()
```

```{r}
# heatmaps - very common in molecular data
library(gplots)
heatmap.2(myList$w,
          dendrogram="both",
          trace="none")
```