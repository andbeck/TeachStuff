---
title: "BirminghamMDIBL"
author: "Andrew P. Beckerman, University of Sheffield"
date: "28 February 2016"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
____________________________________________________
# Part I starts here....
____________________________________________________

## Using R with Rstudio is AWESOME. 
Note that they are different.  R is the engine.  The programming language.  The be-all and end-all.  Rstudio is a wrapper around R.  The maker it a bit betterer.

R and RStudio allow building an annotated, archived, repeatable, share-able cross platform record of what you do.

4 panes: 

* the console (engine)
* the script (your code)
* Plots/Packages
* Data Stuff

![Rstudio Four Panes](figures/RStudioFigure2.png)

## Getting Help
There are many ways.  Inside R, we use `?` and `??` or `help.start()`, which spawns a web browser.  Outside R, we use.... google!  But there is something MUCH better.  Stackoverflow.  This has an R channel, and here you will find VERY constructive answers to questions, including code and graphs.  It has rapidly become the go-to location for help.  Lots of R developers are active there.

[LINK to StackR](http://stackoverflow.com/tags/r/info)

![StackR](figures/StackR.png)

## Using R as a calculator

R is a big giant calculator.  Lets practice in the CONSOLE. Type each of these, and press ENTER. As you do these, WATCH what RStudio does with ()'s

## Practical
```{r, eval = FALSE}
# ----------------------------------------------------------------------
# BASIC PRACTICAL
# ----------------------------------------------------------------------
# Maths and Functions
1+1
2*7/8-9
log(exp(1))
log10(1000)
log(1000)
sin(2*pi)
2^10
sqrt(81)
```

#### *What you should know from this.*

* R does maths correctly
* the default logarithm is the natural log, ln, not base 10
* R has built in function and pre-defined objects

### Try the help - use `?log` to see the help file (lower right) for log....
```{r, eval = FALSE}
# ----------------------------------------------------------------------
# Try the ?
# ----------------------------------------------------------------------

?log
```
## Moving to the script.
Lets start using the script now.  Add some basic annotation at the top, a place holder for libraries (see below) and a good practice activity - clearing R's brain.  Note that the `#` symbol is special.  It designates the verbiage after it as *comment* or *annotation*.  R will NOT try and interpret it.  It is INFORMATION FOR YOU.

```{r, eval = FALSE}
# NAME
# DATE
# Intro to R script

# libraries I need to use

# clear R's brain
rm(list = ls())
```

Now, lets have some more fun... building sequences of numbers to see how R works.  Add each of these lines of code to your script.  Once you've added them, try this.  Simply place the flashing cursor on the line with `1:10`.  Now, press `CTRL - Enter`.  This should send the code from the script to the console.  Don't forget to save your script too!!! 

```{r, eval = FALSE}
# Sequences, Vectorisation
1:10
seq(from = 1, to = 10, by = 1) # note the three arguments, from, to and by
seq(from = 1, to = 10, length = 12) # note the three arguments, from, to and length
```

#### *What you should know from this.*

* R can make sequences of integers easily, via `:`
* seq() is short for *sequence*.  R is like that.
* seq() is a function that takes at least three arguments.
* from, to, by is a sequence in "steps" specified by *by*
* from, to, length is a sequnce of a fixed number of numbers, specified by *length*. 
* Or, it is a vector with *length* numbers between *from* and *to*
* CTRL - Enter sends info from the script to the console.
* `#` is for comments and annotation.

## Assignment of numbers, vectors and data to *objects*
You can make objects in R.  We call this ASSIGNMENT, and we typically use `<-` (not `=`, though it is possible).  Add these to your script and Run each one.

```{r, eval = FALSE}
# assignments
x <- 1:10

# look at it (e.g. press CTRL -ENTER)
x

# use it to make another variable
y <- x^2

# use both operations in additional operations.
# Look at the output carefully!
x+y 
x*y
```

#### *What you should know from this.*

* You can create objects to use.
* The objects can be vectors, matrices, data frames etc.
* R can perform operations with objects.
* operations are by default *element - by - element*
* there is facility for matrix multiplication and linear algebra

## Making some graphics.... BASE graphics

Here we introduce the basics of making a plot.  There are several ways to make pictures.  Some pretty good stuff is built into R.  The most *popular* now is ggplot2, which is an add-on. But there is also the lattice library.  More on packages and libraries below.

To understand how to make a plot, we need to make some data.  Then, we roll these data in to a data frame, which is like a spreadsheet.

```{r}
# Your first DataFrame
x <- 1:10
y <- x^2

# Make a data.frame from this
myDat <- data.frame(Beer = x, Goggles = y)
myDat
```

#### *What you should know from this.*

* data.frame makes a spreadsheet like object with columns
* we name the data frame using `<-`
* we name the columns inside the data.frame using `=`

Right...lets make the picture! We use the base function `plot()` and a *formula* that specifies the y and the x axes of the plot.

```{r}
# Your first plot
# FORMULA INTERFACE
plot(y ~ x, data = myDat, type = "b")
```

#### *What you should know from this.*

* plot is nice
* when the data frame has column names that are nice, they look nice on the graph
* the `type` argument *b* is for both.  *p* is for points only. *l* is for lines only.

## *Semi-*ADVANCED Plots
Plots can be customised.... here we alter the limits of the y-axis (`ylim`), the label on the x-axis (`xlab`), the size points (character expansion: `cex`), and make the points filled (point character; `pch`) with cornflowerblue-ness (`col`) .... and note the `c()` is a collector....`ylim = c(0,120)` specifies that the lower and uppler limit of the y-axis is 0 and 120.

```{r}
# FORMULA INTERFACE
plot(y ~ x, data = myDat, type = "b",
     ylim = c(0,120),
     xlab = "Good Beer",
     pch = 19, cex = 2, col = "cornflowerblue")
```

## Back to some Mechanics... Managing Packages
In your 'omics life, you will need to access packages from TWO locations.  CRAN, which is the *C*omprehensive *R* *A*rchive *N*etwork, and Bioconductor.  

[CRAN](http://star-www.st-andrews.ac.uk/cran/) has ~7500 packages available and they are curated at the CRAN Task Views website:

Packages: [LINK](http://star-www.st-andrews.ac.uk/cran/web/packages/) `http://star-www.st-andrews.ac.uk/cran/web/packages/`

TaskViews: [LINK](http://star-www.st-andrews.ac.uk/cran/web/views/)
`http://star-www.st-andrews.ac.uk/cran/web/views/`

[Bioconductor](https://bioconductor.org) is more focused on 'omics, and has a different curation mechanism

Here are the basics for installing stuff.

```{r, eval = FALSE}
# ----------------------------------------------------------------------
# Installing packages
# ----------------------------------------------------------------------

# R-CRAN
# get gplots, dplyr ggplot2
# see http://ggplot2.org and 
# https://cran.rstudio.com/web/packages/dplyr/vignettes/introduction.html

install.packages(c('gplots','ggplot2', 'dplyr'))

# R - bioconductor
# the first line grabs a special piece of code 
# to make it easy to get packages from BIOCONDUCTOR.
# The second line gets a specific set of packages.... 
# you'll be using these!

source("https://bioconductor.org/biocLite.R")
biocLite(c("DESeq2", "KEGGREST", "pathview","org.Dr.eg.db")
```

Some stuff will happen on your screen when you do this...

Of course, you can also use RStudio to install packages.

![Install](figures/RStudioInstallPKGs.png)



#### Think about packages in this fun way
You should think about packages like this.  You INSTALL PACKAGES from an app store.  This is like downloading the app.  

To use them, however, we need to invoke a second function (like pressing on the icon).  This is called `library()`.  It makes the package and all its Goodness executable.

Typically, we'd do the *intallation* which is a *download* from the app store in the CONSOLE or via RStudio.  Then we need to put the `library()` commands at the top of your script.... Remember we left a place holder for this?

```{r, eval = FALSE}
# I need these libraries
library(KEGGREST)
library(pathview)
library(org.Dr.eg.db)
```

### This is what the beginning of your script might look like....  good practice.
Try and make sure the start of your script is informative, has libraries you need and
clears the deck before starting.

![ScriptStart](figures/ScriptStarter.png)

____________________________________________________
# PART II Starts here....
____________________________________________________

## Reading data in from the web, or your own computer.

Add this to your script.
```{r}
# ----------------------------------------------------------------------
# read some data using read.csv()
# ----------------------------------------------------------------------

# this is a path to data on the web
UrlAddress<-'https://raw.githubusercontent.com/andbeck/RDatas/master/myDF.csv'

# get the data
myDF <- read.csv(UrlAddress)
str(myDF)
```

Don't add this....
```{r, eval = FALSE}
# # with comp
myDF <- read.csv(compAddress)

# # also directly using a path
myDF <- read.csv('~/Documents/Rstuff/file.csv')
```

Add this to your script.... 
```{r}
# ----------------------------
# make a list (also common)
myList <- list(x = 1:10,
   y = LETTERS[1:5],
   w = matrix(rnorm(100,0,1), nrow = 10, ncol = 10, byrow = TRUE))
```

### You will often have data on your computer, from machines etc.  
When you have your own data, you need to know where it is.... 

The path to the folder where the data is... You can use the path directly.
```{r, eval = FALSE}
# # you will often use a path on your computer
## Windows and OSX/Linux use different slashes for paths
##... R no longer cares.

compAddress<-'C:\Documents\RStuff\myDF.csv' # windows
compAddress<-'~/Documents/RStuff/myDF.csv' # linux/unix/osx
```

Or you can set the working directory in RStudio

![setwd](figures/Set Working Directory.png)

And then just provide the file name.

```{r, eval = FALSE}
# After using RStudio to set the working directly
# just define the file

myDf<- read.csv('myDF.csv')
```

## Finding your way around data.

'omics data structures are highly variable.  Things are stored in data frames and in lists.  Below you have 
- an introduction to `[row, column]`, `$` for grabbing bits of data frames
- an introducto to `subset()` for more efficient grabbing
- an introduction to `[[ ]]` for grabbing things from lists

You'll want to work through these.... thoroughly.

-NOTE : lots of people are now using the package dplyr now with verbs `select()`, `slice()`, `filter()` and others as an alternative to BASE functions.  There are VERY good tutorials online.  These are very FAST with LARGE datasets.

```{r}
# ----------------------------------------------------------------------
# Explore the data with important functions in R
# [ ] and $ and ==
# REMEMBER: R works 99% of the time with ROWS THEN COLUMNS...
# e.g. [rows, columns]

# BASE BASICS
myDF[5,2] # 5th row, 2nd column
myDF$expression # use the $ to get the expression column
myDF[,1] # ONLY 1st COLUMN
myDF[2,] # ONLY 2nd ROW
myList[[3]] # double squares for lists; get the 3rd piece of the list => w
```

```{r}
# MORE harder
myList[["w"]][2,] # get the ninth row from the matrix w that is the third element in myList
myList$w[2,] # get the ninth row from the matrix w that is the third element in myList

# MORE Harder
myDF[51:100,] # rows 51:100 are labeled "B"
myDF[myDF$category=="B",] # rows 51:100, but access functionally by definition in category column.
```


```{r}
# ----------------------------------------------------------------------
# learn how to use subset (?subset, perhaps?)
# ----------------------------------------------------------------------
subset(myDF, category=="B") # rows
subset(myDF, select = "expression") # columns
subset(myDF, category=="B", select = "expression") # both
```

## summarising data
Here we introduce the use of BASE functions aggregate and tapply, which are used to generate means, standard deviations etc of data by grouping variables (e.g. parts of experimental designs)

-NOTE - lots of people are using the package dplyr now with verbs `select()`, `slice()`, `filter()` along with `summarise()` and `group_by()`;  VERY good tutorials online

```{r}
# ----------------------------------------------------------------------
# Summarize the data using tapply and aggregate
# ----------------------------------------------------------------------
# aggregate, formulae style.
aggregate(expression ~ category, data = myDF, FUN = mean)

# OR argument style; note that with() declares WHERE to look
# for the column names...

with(myDF, 
	aggregate(x = expression, by = list(category), FUN = mean))

# tapply
with(myDF, 
	tapply(X = expression, INDEX = list(category), FUN = mean))
	
```


```{r}
# YOU CAN assign the values returned by subset, aggregate and tapply to objects
mean.nums <- with(myDF, 
	tapply(X = expression, INDEX = list(category), FUN = mean))

# show me
mean.nums
```

## The apply family and loops
The `apply` family is a very powerfulf family of functions for working with data frames and "applying" functions to rows and columns.  You see above that `tapply()` takes a column of a data frame, divides it up by the levels of a factor from another column, and applies a function to each group.  VERY handy.

The function `apply()` allows us to "apply" a function to each row or column.  This can be very useful.  The first argument is the data frame, the second an indicator (1 or 2) of wheter to work on rows or columns, and the third the function to use.

Lets imagine we want to divide each numeric variable in the small myDat data frame by 10.  This is what we'd do.

```{r}
apply(myDat, 2, function(x) {x/10})
```

Lets dissect this.  We are working with the myDat data frame.  We are going to work on the `COLUMNS`, as we've specified `2`.  The function we are going to use is x/10.  This is interpreted as for every column `x`, do x/10 for every element in x.

Don't get confused by x.  Because we have a `2`, x is EACH column. 

## Transitioning to Unix.
Lets move focus to the console for a moment.... wait.  Have you saved the script?
Use CTRL - 2.  Ohhh - check out the View Menu...
Once in the consol, type:

`ls()`

```{r, echo = FALSE}
# A UNIX LIKE VIEW OF WHAT YOU'VE MADE - did you know that 'ls' is unix command to list files in a directory?
# ls() in R lists objects in the brainspace of R.
# list.files() lists the files in the WORKING directory

# ls() lists the objects in your workspace
ls()
```

Now, lets try a few other commands that are similar in Unix and one extra one.

```{r}
head(myDF) # first six rows
tail(myDF) # last six
str(myDF) # STRUCTURE

getwd() # get the working directory
list.files() # list the files in the working directory

# don't forget.... you can also use the menus via Session -> Set Working Directory to SET the working directory

```

## Loops.
You will use loops.  Loops count for you and do things many times.  Lets look at a simple loop:

`for(i in 1:10) {print(i)}`

This reads, count from 1 to 10, calling the counter i.  At each i, print the number that is i.

Lets look at something more challenging

```{r, echo = TRUE, eval = FALSE}
# Set each array value its native level plus noise
for(i in 1:10){
  array[,i] <- ControlExp + rnorm(1000, sd=.5)
}
```

This has the same counter, but is now adding random numbers (`rnorm()`) to something called *ControlExp*, AND for each i, assigning the sum to the *i'th* column in *array* (which we know is by column because [row,column].

## a more in depth overview of various plottings you can do
MANY methods for making plots with `omics data.
- advanced use of `plot()`
- introduction to `ggplot2`
- introduction to `lattice`

```{r}
# ----------------------------------------------------------------------
# make some different types of plots
# plot, barplot, histograms, heatmaps
# reinforce function and arguments
# ----------------------------------------------------------------------

# plot, using the formula method - the best
plot(expression ~ size, data = myDF, pch = 21, bg = "red",
   xlab="Size", ylab = "Expression")
```

```{r}
# alter the color, and use alpha transparency
plot(expression ~ size, data = myDF, pch = 19, cex = 3, col = rgb(0,0,1,alpha = 0.5))

# specifying categories of colours on the points based on a categorical column
# note the special use of [ ]'s
plot(expression ~ size, data = myDF, 
	pch = 19, col = c("green","blue")[category])
```

```{r}
# lattice graphics - super fun exploration
library(lattice) # loads a special graphics library into R's brain

xyplot(expression ~ size | category, data = myDF) # panels
xyplot(expression ~ size, groups = category, data = myDF) # groups

# ggplot graphics - very popular now too
library(ggplot2)
ggplot(myDF, aes(x = size, y = expression))+
	geom_point(col = "red")+
	facet_wrap(~category)

ggplot(myDF, aes(x = size, y = expression, col = category))+
	geom_point()
```

```{r}
# heatmaps - very common in molecular data
library(gplots)
heatmap.2(myList$w,
          dendrogram="both",
          trace="none")
```